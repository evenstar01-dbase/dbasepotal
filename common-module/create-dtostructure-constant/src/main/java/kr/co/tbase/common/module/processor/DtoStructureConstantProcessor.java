package kr.co.tbase.common.module.processor;

import static javax.lang.model.element.ElementKind.PACKAGE;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Deque;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.MirroredTypesException;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.type.WildcardType;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic;

import org.apache.commons.text.StringEscapeUtils;

import com.google.auto.service.AutoService;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

import io.swagger.v3.oas.annotations.media.Schema;
import kr.co.tbase.common.module.annotation.MakeDtoStructure;

/**
 * MakeDtoStructure 어노테이션에 입력된 클래스들을 분석해 json 문자열로
 * 만들어 자바 상수로 만들어주는 프로세서
 */
@SuppressWarnings({"java:S112", "java:S106"})
@AutoService(Processor.class)
public class DtoStructureConstantProcessor extends AbstractProcessor {
    private static final String COMMENT_PREFIX = "// ";

    Elements elementUtils;
    Types typeUtils;
    DeclaredType collectionType;
    DeclaredType listType;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        try {
            elementUtils = processingEnv.getElementUtils();
            typeUtils = processingEnv.getTypeUtils();
            collectionType = classToDeclaredType(Collection.class);
            listType = classToDeclaredType(List.class);
        } catch (Exception ex) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, ex.toString());
            throw new RuntimeException(ex);
        }
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnvironment) {
        var elements = roundEnvironment.getElementsAnnotatedWith(MakeDtoStructure.class);
        for (var element : elements) {
            MakeDtoStructure extractEntityConstant = element.getAnnotation(MakeDtoStructure.class);
            if (!generateClasses(extractEntityConstant, findPackageName(element))) {
                return false;
            }
        }

        return true;
    }

    private boolean generateClasses(MakeDtoStructure makeDtoStructure, String packageName) {
        try {
            var declaredTypes = getDeclaredTypes(makeDtoStructure);
            var dtoStructureSpec = dtoStructureSpec(ClassName.get(packageName, makeDtoStructure.structureDetailContainer()), declaredTypes);

            JavaFile.builder(packageName, dtoStructureSpec).indent("    ").build().writeTo(processingEnv.getFiler());
        } catch (Exception ex) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, ex.getMessage());
            return false;
        }

        return true;
    }

    private TypeSpec dtoStructureSpec(ClassName className, List<DeclaredType> declaredTypes) {
        return TypeSpec.classBuilder(className)
                .addModifiers(PUBLIC)
                .addFields(declaredTypes.stream().map(this::toDtoDetail).collect(Collectors.toList()))
                .build();
    }

    private FieldSpec toDtoDetail(DeclaredType declaredType) {
        var dtoName = dtoName(declaredType);
        return FieldSpec.builder(String.class, dtoName, PUBLIC, STATIC, FINAL)
                .initializer(dtoStructureJsonString(declaredType))
                .addJavadoc("auto generated by @" + MakeDtoStructure.class.getSimpleName())
                .build();
    }

    private String dtoName(DeclaredType declaredType) {
        return declaredType.asElement().getSimpleName().toString();
    }

    private String dtoStructureJsonString(DeclaredType declaredType) {
        GsonBuilder gsonBuilder = new GsonBuilder();
        Gson gson = gsonBuilder.setPrettyPrinting().create();
        Deque<DeclaredType> visited = new ArrayDeque<>();

        return jsonStringToJavaLiteral(gson.toJson(declaredTypeToJsonElement(declaredType, visited)));
    }

    private JsonElement declaredTypeToJsonElement(DeclaredType declaredType, Deque<DeclaredType> visited) {
        if (visited.contains(declaredType)) {
            return null;
        }

        if (declaredType.asElement().getKind() != ElementKind.CLASS) {
            throw new RuntimeException("클래스 타입이 아닌 DTO는 처리할 수 없습니다.");
        }

        var element = declaredType.asElement();
        if (!(element instanceof TypeElement)) {
            throw new RuntimeException("타입 엘레멘트만 처리 가능합니다.");
        }

        List<Element> allFieldElements = allFieldElements((TypeElement) element);

        visited.push(declaredType);
        JsonObject jsonObject = new JsonObject();
        allFieldElements.forEach(currentFieldElement -> addFieldElementDescriptorToJson(jsonObject, currentFieldElement, visited));
        visited.pop();

        return jsonObject;
    }

    private String jsonStringToJavaLiteral(String jsonString) {
        String[] jsonStrings = jsonString.split("\n");
        return Arrays.stream(jsonStrings)
                .map(StringEscapeUtils::escapeJava)
                .map(s -> "\"" + s + "\\n\\n\"")
                .collect(Collectors.joining("\n+ "));
    }

    private DeclaredType classToDeclaredType(Class<?> clazz) {
        TypeElement collectionTypeElement = this.elementUtils.getTypeElement(clazz.getName());
        WildcardType wildCardTypeNull = this.typeUtils.getWildcardType(null, null);
        TypeMirror[] wildCardTypeMirrors = {wildCardTypeNull};
        return this.typeUtils.getDeclaredType(collectionTypeElement, wildCardTypeMirrors);
    }

    private List<Element> allFieldElements(TypeElement element) {
        TypeElement superElement = element;
        List<Element> allFieldElements = new ArrayList<>();
        while (true) {
            allFieldElements.addAll(
                    superElement.getEnclosedElements()
                            .stream()
                            .filter(e -> e.getKind() == ElementKind.FIELD)
                            .collect(Collectors.toList())
            );

            var tmpSuper = superElement.getSuperclass();
            if (tmpSuper == null || tmpSuper.getKind() != TypeKind.DECLARED) {
                break;
            }

            superElement = (TypeElement) ((DeclaredType) tmpSuper).asElement();
        }
        return allFieldElements;
    }

    private void addFieldElementDescriptorToJson(JsonObject jsonObject, Element currentFieldElement, Deque<DeclaredType> visited) {
        Schema schema = currentFieldElement.getAnnotation(Schema.class);
        if (schema == null) {
            return;
        }

        if (!(currentFieldElement instanceof VariableElement)) {
            System.err.println("element is not instance of VariableElement");
            return;
        }

        String commentForCurrentField = COMMENT_PREFIX + Optional.ofNullable(schema.description()).orElse("TODO: need to write schema description");
        VariableElement ve = (VariableElement) currentFieldElement;
        if (ve.asType().getKind().isPrimitive()) {
            // primitive인 경우
            jsonObject.addProperty(currentFieldElement.getSimpleName().toString(), commentForCurrentField);
            return;
        }

        TypeMirror typeMirrorOfElement = ve.asType();
        DeclaredType declaredTypeOfElement = (DeclaredType) typeMirrorOfElement;
        if (typeUtils.isAssignable(typeMirrorOfElement, listType)) {
            // List타입인 경우
            TypeMirror typeMirrorOfActual = declaredTypeOfElement.getTypeArguments().stream().findFirst().orElse(null);
            JsonArray jsonArray = new JsonArray();
            if (typeMirrorOfActual != null && isDeclaredTypeAnnotatedBySchema((DeclaredType) typeMirrorOfActual)) {
                JsonObject commentObject = new JsonObject();
                commentObject.addProperty("_comment_of_this_list", commentForCurrentField);
                jsonArray.add(commentObject);
                jsonArray.add(declaredTypeToJsonElement((DeclaredType) typeMirrorOfActual, visited));
            } else {
                jsonArray.add(commentForCurrentField);
            }
            jsonObject.add(currentFieldElement.getSimpleName().toString(), jsonArray);
            return;
        }

        if (isDeclaredTypeAnnotatedBySchema(declaredTypeOfElement)) {
            // Schema 어노테이션이 선언된 클래스(DTO 등)인 경우
            jsonObject.add(currentFieldElement.getSimpleName().toString(), declaredTypeToJsonElement((DeclaredType) typeMirrorOfElement, visited));
            return;
        }

        // Schema가 선언되지 않은 타입인 경우
        jsonObject.addProperty(currentFieldElement.getSimpleName().toString(), commentForCurrentField);
    }

    private boolean isDeclaredTypeAnnotatedBySchema(DeclaredType declaredType) {
        return declaredType.asElement().getAnnotation(Schema.class) != null;
    }

    private List<DeclaredType> getDeclaredTypes(MakeDtoStructure extractEntityConstant) {
        try {
            log("..." + Arrays.stream(extractEntityConstant.targetClasses()).collect(Collectors.toList()));
        } catch (MirroredTypesException e) {
            return e.getTypeMirrors().stream()
//                    .filter(typeMirror -> typeMirror instanceof DeclaredType)
                    .map(DeclaredType.class::cast)
                    .collect(Collectors.toList());
        }
        throw new RuntimeException("can not get type mirrors");
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Set.of(MakeDtoStructure.class.getCanonicalName());
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.RELEASE_11;
    }

    private String findPackageName(Element e) {
        Element currentElement = e;
        while (currentElement.getKind() != PACKAGE) {
            currentElement = currentElement.getEnclosingElement();
        }
        return ((PackageElement) currentElement).getQualifiedName().toString();
    }

    @SuppressWarnings("java:S106")
    private void log(String str) {
        System.out.println(str);
    }
}
